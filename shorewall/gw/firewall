#!/bin/sh
#
# Compiled firewall script generated by Shorewall 4.5.21.6 - Wed Mar 18 15:36:09 2015
#
#     This program is under GPL [http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt]
#
#     (c) 1999-2012 - Tom Eastep (teastep@shorewall.net)
#
#	Options are:
#
#	    -n				  Don't alter Routing
#	    -v and -q			  Standard Shorewall Verbosity control
#           -t                            Timestamp progress messages
#           -p                            Purge conntrack table
#           -r                            Recover from failed start/restart
#           -V <verbosity>                Set verbosity level explicitly
#           -R <restore>                  Overrides RESTOREFILE setting
#
#	Commands are:
#
#	   start			  Starts the firewall
#          refresh                        Refresh the firewall
#	   restart			  Restarts the firewall
#	   reload			  Reload the firewall
#	   clear			  Removes all firewall rules
#	   stop				  Stops the firewall
#	   status			  Displays firewall status
#	   version			  Displays the version of Shorewall that
#	   				  generated this program
#
################################################################################
# Functions imported from /usr/share/shorewall/lib.core
################################################################################
#                     Address family-neutral Functions
################################################################################
#
# Conditionally produce message
#
progress_message() # $* = Message
{
    local timestamp
    timestamp=

    if [ $VERBOSITY -gt 1 ]; then
	[ -n "$g_timestamp" ] && timestamp="$(date +%H:%M:%S) "
	echo "${timestamp}$@"
    fi

    if [ $LOG_VERBOSITY -gt 1 ]; then
        timestamp="$(date +'%b %_d %T') "
        echo "${timestamp}$@" >> $STARTUP_LOG
    fi
}

progress_message2() # $* = Message
{
    local timestamp
    timestamp=

    if [ $VERBOSITY -gt 0 ]; then
	[ -n "$g_timestamp" ] && timestamp="$(date +%H:%M:%S) "
	echo "${timestamp}$@"
    fi

    if [ $LOG_VERBOSITY -gt 0 ]; then
        timestamp="$(date +'%b %_d %T') "
        echo "${timestamp}$@" >> $STARTUP_LOG
    fi
}

progress_message3() # $* = Message
{
    local timestamp
    timestamp=

    if [ $VERBOSITY -ge 0 ]; then
	[ -n "$g_timestamp" ] && timestamp="$(date +%H:%M:%S) "
	echo "${timestamp}$@"
    fi

    if [ $LOG_VERBOSITY -ge 0 ]; then
        timestamp="$(date +'%b %_d %T') "
        echo "${timestamp}$@" >> $STARTUP_LOG
    fi
}

#
# Set a standard chain's policy
#
setpolicy() # $1 = name of chain, $2 = policy
{
    run_iptables -P $1 $2
}

#
# Generate a list of all network interfaces on the system
#
find_all_interfaces() {
    ${IP:-ip} link list | egrep '^[[:digit:]]+:' | cut -d ' ' -f2 | sed -r 's/(@.*)?:$//'
}

#
# Generate a list of all network interfaces on the system that have an ipvX address
#
find_all_interfaces1() {
    ${IP:-ip} -$g_family addr list | egrep '^[[:digit:]]+:' | cut -d ' ' -f2 | sed -r 's/(@.*)?:$//'
}

#
# Find the value 'dev' in the passed arguments then echo the next value
#

find_device() {
    while [ $# -gt 1 ]; do
	[ "x$1" = xdev ] && echo $2 && return
	shift
    done
}

#
# Find the value 'via' in the passed arguments then echo the next value
#

find_gateway() {
    while [ $# -gt 1 ]; do
	[ "x$1" = xvia ] && echo $2 && return
	shift
    done
}

#
# Find the value 'mtu' in the passed arguments then echo the next value
#

find_mtu() {
    while [ $# -gt 1 ]; do
	[ "x$1" = xmtu ] && echo $2 && return
	shift
    done
}

#
# Find the value 'peer' in the passed arguments then echo the next value up to
# "/"
#

find_peer() {
    while [ $# -gt 1 ]; do
	[ "x$1" = xpeer ] && echo ${2%/*} && return
	shift
    done
}

#
# Try to find the gateway through an interface looking for 'nexthop'

find_nexthop() # $1 = interface
{
    echo $(find_gateway `$IP -$g_family route list | grep "[[:space:]]nexthop.* $1"`)
}

#
# Find the default route's interface
#
find_default_interface() {
    $IP -$g_family route list | while read first rest; do
	[ "$first" = default ] && echo $(find_device $rest) && return
    done
}

#
# Determine if Interface is up
#
interface_is_up() {
    [ -n "$($IP -$g_family link list dev $1 2> /dev/null | grep -e '[<,]UP[,>]')" ]
}

#
#  echo the list of networks routed out of a given interface
#
get_routed_networks() # $1 = interface name, $2-n = Fatal error message
{
    local address
    local rest
    local mask

    [ $g_family -eq 4 ] && mask=32 || mask=128

    $IP -$g_family route show dev $1 2> /dev/null |
	while read address rest; do
	    case "$address" in
		default)
		    if [ $# -gt 1 ]; then
			shift
			fatal_error "$@"
		    else
			echo "WARNING: default route ignored on interface $1" >&2
		    fi
		    ;;
		multicast|broadcast|prohibit|nat|throw|nexthop)
		    ;;
		[2-3]*)
		    [ "$address" = "${address%/*}" ] && address="${address}/${mask}"
		    echo $address
		    ;;
		*)
		    if [ $g_family -eq 4 ]; then
			[ "$address" = "${address%/*}" ] && address="${address}/${mask}"
			echo $address
		    fi
		    ;;
	    esac
        done
}

#
# Clear the current traffic shaping configuration
#

delete_tc1()
{
    clear_one_tc() {
        $TC qdisc del dev ${1%@*} root 2> /dev/null
        $TC qdisc del dev ${1%@*} ingress 2> /dev/null

    }

    run_tcclear_exit

    run_ip link list | \
    while read inx interface details; do
        case $inx in
            [0-9]*)
                clear_one_tc ${interface%:}
                ;;
            *)
                ;;
        esac
    done
}

#
# Detect a device's MTU -- echos the passed device's MTU
#
get_device_mtu() # $1 = device
{
    local output
    output="$($IP link list dev $1 2> /dev/null)" # quotes required for /bin/ash

    if [ -n "$output" ]; then
	echo $(find_mtu $output)
    else
	echo 1500
    fi
}

#
# Version of the above that doesn't generate any output for MTU 1500.
# Generates 'mtu <mtu+>' otherwise, where <mtu+> is the device's MTU + 100
#
get_device_mtu1() # $1 = device
{
    local output
    output="$($IP link list dev $1 2> /dev/null)" # quotes required for /bin/ash
    local mtu

    if [ -n "$output" ]; then
	mtu=$(find_mtu $output)
	if [ -n "$mtu" ]; then
	    [ $mtu = 1500 ] || echo mtu $(($mtu + 100))
	fi
    fi

}

#
# Undo changes to routing
#
undo_routing() {
    local undofiles
    local f

    if [ -z "$g_noroutes"  ]; then
	#
	# Restore rt_tables database
	#
	if [ -f ${VARDIR}/rt_tables ]; then
	    [ -w /etc/iproute2/rt_table -a -z "$KEEP_RT_TABLES" ] && cp -f ${VARDIR}/rt_tables /etc/iproute2/ && progress_message "/etc/iproute2/rt_tables database restored"
	    rm -f ${VARDIR}/rt_tables
	fi
	#
	# Restore the rest of the routing table
	#
	undofiles="$(ls ${VARDIR}/undo_*routing 2> /dev/null)"

	if [ -n "$undofiles" ]; then
	    for f in $undofiles; do
		. $f
	    done

	    rm -f $undofiles

            progress_message "Shorewall-generated routing tables and routing rules removed"
	fi
    fi

}

#
# Save the default route
#
save_default_route() {
    awk \
    'BEGIN        {defroute=0;};
     /^default /  {defroute=1; print; next};
     /nexthop/    {if (defroute == 1 ) {print ; next} };
                  { defroute=0; };'
}

#
# Restore the default route that was in place before the initial 'shorewall start'
#
replace_default_route() # $1 = USE_DEFAULT_RT
{
    #
    # default_route and result are inherited from the caller
    #
    if [ -n "$default_route" ]; then
	case "$default_route" in
	    *metric*)
	        #
	        # Don't restore a default route with a metric unless USE_DEFAULT_RT=Yes. Otherwise, we only replace the one with metric 0
	        #
		[ -n "$1" ] && qt $IP -$g_family route replace $default_route && progress_message "Default Route (${default_route# }) restored"
		default_route=
		;;
	    *)
		qt $IP -$g_family route replace $default_route && progress_message "Default Route (${default_route# }) restored"
		result=0
		default_route=
		;;
	esac
    fi
}

#
# Delete default routes with metric 0 from the passed routing table
#
delete_default_routes() # $1 = table number
{
    $IP -$g_family route ls table $1 | grep -F default | grep -vF metric | while read route; do
	qt $IP -$g_family route del $route
    done
} 

restore_default_route() # $1 = USE_DEFAULT_RT
{
    local result
    result=1

    if [ -z "$g_noroutes" -a -f ${VARDIR}/default_route ]; then
	local default_route
	default_route=
	local route

	while read route ; do
	    case $route in
		default*)
		    replace_default_route $1
		    default_route="$default_route $route"
		    ;;
		*)
		    default_route="$default_route $route"
		    ;;
	    esac
	done < ${VARDIR}/default_route

	replace_default_route $1

	if [ $result = 1 ]; then
	    #
	    # We didn't restore a default route with metric 0
	    #
	    if $IP -$g_family -o route list 2> /dev/null | grep -F default | grep -qvF metric; then
	       #
	       # But we added a default route with metric 0
	       #
	       qt $IP -$g_family route del default metric 0 && progress_message "Default route with metric 0 deleted"
	    fi
	fi

	rm -f ${VARDIR}/default_route
    fi

    return $result
}

#
# Flush the conntrack table if $g_purge is non-empty
#
conditionally_flush_conntrack() {

    if [ -n "$g_purge" ]; then
	if [ -n $(mywhich conntrack) ]; then
            conntrack -F
	else
            error_message "WARNING: The '-p' option requires the conntrack utility which does not appear to be installed on this system"
	fi
    fi
}

#
# Issue a message and stop/restore the firewall.
#
fatal_error()
{
    echo "   ERROR: $@" >&2

    if [ $LOG_VERBOSITY -ge 0 ]; then
        timestamp="$(date +'%_b %d %T') "
        echo "${timestamp}  ERROR: $@" >> $STARTUP_LOG
    fi

    stop_firewall
    [ -n "$TEMPFILE" ] && rm -f $TEMPFILE
    mutex_off
    exit 2
}

#
# Run iptables/ip6tables and if an error occurs, stop/restore the firewall
#
run_iptables()
{
    local status

    while [ 1 ]; do
	eval $g_tool $@
	status=$?
	[ $status -ne 4 ] && break
    done

    if [ $status -ne 0 ]; then
        error_message "ERROR: Command \"$g_tool $@\" Failed"
	stop_firewall
        exit 2
    fi
}

#
# Run iptables/ip6tables retrying exit status 4
#
do_iptables()
{
    local status

    while [ 1 ]; do
	$g_tool $@
	status=$?
	[ $status -ne 4 ] && return $status;
    done
}

#
# Run ip and if an error occurs, stop/restore the firewall
#
run_ip()
{
    if ! $IP -$g_family $@; then
	error_message "ERROR: Command \"$IP -$g_family $@\" Failed"
	stop_firewall
	exit 2
    fi
}

#
# Run tc and if an error occurs, stop/restore the firewall
#
run_tc() {
    if ! $TC $@ ; then
	error_message "ERROR: Command \"$TC $@\" Failed"
	stop_firewall
	exit 2
    fi
}

#
# Run the .iptables_restore_input as a set of discrete iptables commands
#
debug_restore_input() {
    local first second rest table chain
    #
    # Clear the ruleset
    #
    qt1 $g_tool -t mangle -F
    qt1 $g_tool -t mangle -X

    for chain in PREROUTING INPUT FORWARD POSTROUTING; do
	qt1 $g_tool -t mangle -P $chain ACCEPT
    done

    qt1 $g_tool -t raw    -F
    qt1 $g_tool -t raw    -X

    for chain in PREROUTING OUTPUT; do
	qt1 $g_tool -t raw -P $chain ACCEPT
    done

    qt1 $g_tool -t rawpost -F
    qt1 $g_tool -t rawpost    -X

    for chain in POSTROUTING; do
	qt1 $g_tool -t rawpost -P $chain ACCEPT
    done

    qt1 $g_tool -t nat    -F
    qt1 $g_tool -t nat    -X

    for chain in PREROUTING POSTROUTING; do
        qt1 $g_tool -t nat -P $chain ACCEPT
    done

    qt1 $g_tool -t filter -F
    qt1 $g_tool -t filter -X

    for chain in INPUT FORWARD OUTPUT; do
	qt1 $g_tool -t filter -P $chain -P ACCEPT
    done

    while read first second rest; do
	case $first in
	    -*)
		#
		# We can't call run_iptables() here because the rules may contain quoted strings
		#
		eval $g_tool -t $table $first $second $rest

		if [ $? -ne 0 ]; then
		    error_message "ERROR: Command \"$g_tool $first $second $rest\" Failed"
		    stop_firewall
		    exit 2
		fi
		;;
	    :*)
		chain=${first#:}

		if [ "x$second" = x- ]; then
		    do_iptables -t $table -N $chain
		else
		    do_iptables -t $table -P $chain $second
		fi

		if [ $? -ne 0 ]; then
		    error_message "ERROR: Command \"$g_tool $first $second $rest\" Failed"
		    stop_firewall
		    exit 2
		fi
		;;
	    #
	    # This grotesque hack with the table names works around a bug/feature with ash
	    #
	    '*'raw)
		table=raw
		;;
	    '*'rawpost)
		table=rawpost
		;;
	    '*'mangle)
		table=mangle
		;;
	    '*'nat)
		table=nat
		;;
	    '*'filter)
		table=filter
		;;
	esac
    done
}

interface_up() {
    return $(cat ${VARDIR}/$1.status)
}

distribute_load() {
    local interface
    local totalload
    local load
    local mark
    local maxload

    maxload=$1
    shift

    totalload=0

    for interface in $@; do
	if interface_up $interface; then
	    load=$(cat ${VARDIR}/${interface}_load)
	    eval ${interface}_load=$load
	    mark=$(cat ${VARDIR}/${interface}_mark)
	    eval ${interface}_mark=$mark
	    totalload=$( bc <<EOF
scale=8
$totalload + $load
EOF
)
	fi
    done

    if [ $totalload ]; then
	for interface in $@; do
	    qt $g_tool -t mangle -F ~$interface
	    eval load=\$${interface}_load
	    eval mark=\$${interface}_mark

	    if [ -n "$load" ]; then
		load=$(bc <<EOF
scale=8
( $load / $totalload ) * $maxload
EOF
)
		totalload=$(bc <<EOF
scale=8
$totalload - $load
EOF
)
		run_iptables -t mangle -A ~$interface -m statistic --mode random --probability $load -j MARK --set-mark $mark
	    fi
	done
    fi
}

#################################################################################
#                        IPv4-specific Functions
#################################################################################
#
# Determine if interface is usable from a Netfilter perspective
#
interface_is_usable() # $1 = interface
{
    local status;
    status=0

    if [ "$1" != lo ]; then
	if interface_is_up $1 && [ "$(find_first_interface_address_if_any $1)" != 0.0.0.0 ]; then
	    [ "$COMMAND" = enable ] || run_isusable_exit $1
	    status=$?
	else
	    status=1
	fi
    fi

    return $status
}

#
# Find interface addresses--returns the set of addresses assigned to the passed device
#
find_interface_addresses() # $1 = interface
{
    $IP -f inet addr show $1 2> /dev/null | grep inet\  | sed 's/\s*inet //;s/\/.*//;s/ peer.*//'
}

#
# Find the value 'weight' in the passed arguments then echo the next value
#
find_weight() {
    while [ $# -gt 1 ]; do
	[ "x$1" = xweight ] && echo $2 && return
	shift
    done
}

#
# Find the interfaces that have a route to the passed address - the default
# route is not used.
#

find_rt_interface() {
    $IP -4 route list | while read addr rest; do
	case $addr in
	    */*)
		in_network ${1%/*} $addr && echo $(find_device $rest)
		;;
	    default)
		;;
	    *)
		if [ "$addr" = "$1" -o "$addr/32" = "$1" ]; then
		    echo $(find_device $rest)
		fi
		;;
	esac
    done
}

#
# Echo the name of the interface(s) that will be used to send to the
# passed address
#

find_interface_by_address() {
    local dev
    dev="$(find_rt_interface $1)"
    local first
    local rest

    [ -z "$dev" ] && dev=$(find_default_interface)

    [ -n "$dev" ] && echo $dev
}

#
#  echo the list of networks routed out of a given interface
#
get_routed_networks() # $1 = interface name, $2-n = Fatal error message
{
    local address
    local rest

    $IP -4 route show dev $1 2> /dev/null |
	while read address rest; do
	    case "$address" in
		default)
		    if [ $# -gt 1 ]; then
			shift
			fatal_error "$@"
		    else
			echo "WARNING: default route ignored on interface $1" >&2
		    fi
		    ;;
		multicast|broadcast|prohibit|nat|throw|nexthop)
		    ;;
		*)
		    [ "$address" = "${address%/*}" ] && address="${address}/32"
		    echo $address
		    ;;
	    esac
        done
}

#
# Get the broadcast addresses associated with an interface
#
get_interface_bcasts() # $1 = interface
{
    local addresses
    addresses=

    $IP -f inet addr show dev $1 2> /dev/null | grep 'inet.*brd' | sed 's/inet.*brd //; s/scope.*//;' | sort -u
}

#
# Delete IP address
#
del_ip_addr() # $1 = address, $2 = interface
{
    [ $(find_first_interface_address_if_any $2) = $1 ] || qtnoin $IP addr del $1 dev $2
}

# Add IP Aliases
#
add_ip_aliases() # $* = List of addresses
{
    local local
    local addresses
    local external
    local interface
    local inet
    local cidr
    local rest
    local val
    local arping
    arping=$(mywhich arping)

    address_details()
    {
	#
	# Folks feel uneasy if they don't see all of the same
	# decoration on these IP addresses that they see when their
	# distro's net config tool adds them. In an attempt to reduce
	# the anxiety level, we have the following code which sets
	# the VLSM and BRD from an existing address in the same network
	#
	# Get all of the lines that contain inet addresses with broadcast
	#
	$IP -f inet addr show $interface 2> /dev/null | grep 'inet.*brd' | while read inet cidr rest ; do
	    case $cidr in
		*/*)
		    if in_network $external $cidr; then
			echo "/${cidr#*/} brd $(broadcastaddress $cidr)"
			break
		    fi
		    ;;
	    esac
	done
    }

    do_one()
    {
	val=$(address_details)

	$IP addr add ${external}${val} dev $interface $label
	[ -n "$arping" ] && qt $arping -U -c 2 -I $interface $external
	echo "$external $interface" >> $VARDIR/nat
	[ -n "$label" ] && label="with $label"
	progress_message "   IP Address $external added to interface $interface $label"
    }

    progress_message "Adding IP Addresses..."

    while [ $# -gt 0 ]; do
	external=$1
	interface=$2
	label=

	if [ "$interface" != "${interface%:*}" ]; then
	    label="${interface#*:}"
	    interface="${interface%:*}"
	    label="label $interface:$label"
	fi

	shift 2

	list_search $external $(find_interface_addresses $interface) || do_one
    done
}

#
# Detect the gateway through a PPP or DHCP-configured interface
#
detect_dynamic_gateway() { # $1 = interface
    local interface
    interface=$1
    local GATEWAYS
    GATEWAYS=
    local gateway

    gateway=$(run_findgw_exit $1);

    if [ -z "$gateway" ]; then
	gateway=$( find_peer $($IP addr list $interface ) )
    fi

    if [ -z "$gateway" -a -f ${VARLIB}/dhcpcd/dhcpcd-${1}.info ]; then
	eval $(grep ^GATEWAYS=  ${VARLIB}/dhcpcd/dhcpcd-${1}.info 2> /dev/null)
	[ -n "$GATEWAYS" ] && GATEWAYS=${GATEWAYS%,*} && gateway=$GATEWAYS
    fi

    if [ -z "$gateway" -a -f ${VARLIB}/dhcp/dhclient-${1}.lease ]; then
	gateway=$(grep 'option routers' ${VARLIB}/dhcp/dhclient-${1}.lease | tail -n 1 | while read j1 j2 gateway; do echo $gateway ; return 0; done)
    fi

    [ -n "$gateway" ] && echo $gateway
}

#
# Detect the gateway through an interface
#
detect_gateway() # $1 = interface
{
    local interface
    interface=$1
    local gateway
    #
    # First assume that this is some sort of dynamic interface
    #
    gateway=$( detect_dynamic_gateway $interface )
    #
    # Maybe there's a default route through this gateway already
    #
    [ -n "$gateway" ] || gateway=$(find_gateway $($IP -4 route list dev $interface | grep ^default))
    #
    # Last hope -- is there a load-balancing route through the interface?
    #
    [ -n "$gateway" ] || gateway=$(find_nexthop $interface)
    #
    # Be sure we found one
    #
    [ -n "$gateway" ] && echo $gateway
}

#
# Disable IPV6
#
disable_ipv6() {
    local foo
    foo="$($IP -f inet6 addr list 2> /dev/null)"

    if [ -n "$foo" ]; then
	if [ -x "$IP6TABLES" ]; then
	    $IP6TABLES -P FORWARD DROP
	    $IP6TABLES -P INPUT DROP
	    $IP6TABLES -P OUTPUT DROP
	    $IP6TABLES -F
	    $IP6TABLES -X
	    $IP6TABLES -A OUTPUT -o lo -j ACCEPT
	    $IP6TABLES -A INPUT -i lo -j ACCEPT
	else
	    error_message "WARNING: DISABLE_IPV6=Yes in shorewall.conf but this system does not appear to have ip6tables"
	fi
    fi
}

#
# Add an additional gateway to the default route
#
add_gateway() # $1 = Delta $2 = Table Number
{
    local route
    local weight
    local delta
    local dev

    route=`$IP -4 -o route ls table $2 | grep ^default | sed 's/default //; s/[\]//g'`

    if [ -z "$route" ]; then
	run_ip route add default scope global table $2 $1
    else
	delta=$1

	if ! echo $route | grep -qF ' nexthop '; then
	    if echo $route | grep -qF via; then
		route=`echo $route | sed 's/via/nexthop via/'`
	    else
		route="nexthop $route"
	    fi

	    dev=$(find_device $route)
	    if [ -f ${VARDIR}/${dev}_weight ]; then
		weight=`cat ${VARDIR}/${dev}_weight`
		route="$route weight $weight"
	    fi
	fi

	run_ip route replace default scope global table $2 $route $delta
    fi
}

#
# Remove a gateway from the default route
#
delete_gateway() # $! = Description of the Gateway $2 = table number $3 = device
{
    local route
    local gateway
    local dev

    route=`$IP -4 -o route ls table $2 | grep ^default | sed 's/[\]//g'`
    gateway=$1

    if [ -n "$route" ]; then
	if echo $route | grep -qF ' nexthop '; then
	    gateway="nexthop $gateway"
	    eval route=\`echo $route \| sed \'s/$gateway/ /\'\`
	    run_ip route replace table $2 $route
	else
	    dev=$(find_device $route)
	    [ "$dev" = "$3" ] && run_ip route delete default table $2
	fi
    fi
}

#
# Determine the MAC address of the passed IP through the passed interface
#
find_mac() # $1 = IP address, $2 = interface
{
    if interface_is_usable $2 ; then
	qt ping -nc 1 -t 2 -I $2 $1

	local result
	result=$($IP neigh list |  awk "/^$1 / {print \$5}")

	case $result in
	    \<*\>)
		;;
	    *)
		[ -n "$result" ] && echo $result
		;;
	esac
    fi
}

#
# Clear Proxy Arp
#
delete_proxyarp() {
    if [ -f ${VARDIR}/proxyarp ]; then
	while read address interface external haveroute; do
	    qtnoin $IP -4 neigh del proxy $address dev $external
	    [ -z "${haveroute}${g_noroutes}" ] && qtnoin $IP -4 route del $address/32 dev $interface
	    f=/proc/sys/net/ipv4/conf/$interface/proxy_arp
	    [ -f $f ] && echo 0 > $f
	done < ${VARDIR}/proxyarp

	rm -f ${VARDIR}/proxyarp
    fi
}

#
# Remove all Shorewall-added rules
#
clear_firewall() {
    stop_firewall

    setpolicy INPUT ACCEPT
    setpolicy FORWARD ACCEPT
    setpolicy OUTPUT ACCEPT

    run_iptables -F
    qt $IPTABLES -t raw -F

    echo 1 > /proc/sys/net/ipv4/ip_forward

    if [ -n "$DISABLE_IPV6" ]; then
	if [ -x $IP6TABLES ]; then
    	    $IP6TABLES -P INPUT   ACCEPT 2> /dev/null
	    $IP6TABLES -P OUTPUT  ACCEPT 2> /dev/null
	    $IP6TABLES -P FORWARD ACCEPT 2> /dev/null
	fi
    fi

    run_clear_exit

    set_state "Cleared"

    logger -p kern.info "$g_product Cleared"
}

#
# Get a list of all configured broadcast addresses on the system
#
get_all_bcasts()
{
    $IP -f inet addr show 2> /dev/null | grep 'inet.*brd' | grep -v '/32 ' | sed 's/inet.*brd //; s/scope.*//;' | sort -u
}

################################################################################
#   Functions imported from /usr/share/shorewall//lib.common
################################################################################

startup_error() # $* = Error Message
{
    echo "   ERROR: $@: Firewall state not changed" >&2

    if [ $LOG_VERBOSITY -ge 0 ]; then
        timestamp="$(date +'%_b %d %T') "
        echo "${timestamp}  ERROR: $@" >> $STARTUP_LOG
    fi

    case $COMMAND in
        start)
	    logger -p kern.err "ERROR:$g_product start failed:Firewall state not changed"
	    ;;
	restart)
	    logger -p kern.err "ERROR:$g_product restart failed:Firewall state not changed"
	    ;;
	restore)
	    logger -p kern.err "ERROR:$g_product restore failed:Firewall state not changed"
	    ;;
    esac

    if [ $LOG_VERBOSITY -ge 0 ]; then
        timestamp="$(date +'%_b %d %T') "

	case $COMMAND in
	    start)
		echo "${timestamp}  ERROR:$g_product start failed:Firewall state not changed" >> $STARTUP_LOG
		;;
	    restart)
		echo "${timestamp}  ERROR:$g_product restart failed:Firewall state not changed" >> $STARTUP_LOG
		;;
	    restore)
		echo "${timestamp}  ERROR:$g_product restore failed:Firewall state not changed" >> $STARTUP_LOG
		;;
	esac
    fi

    mutex_off
    kill $$
    exit 2
}

#
# Get the Shorewall version of the passed script
#
get_script_version() { # $1 = script
    local temp
    local version
    local ifs
    local digits
    local verbosity

    verbosity="$VERBOSITY"
    VERBOSITY=0

    temp=$( $SHOREWALL_SHELL $1 version | tail -n 1 | sed 's/-.*//' )

    if [ -z "$temp" ]; then
	version=0
    else
	ifs=$IFS
	IFS=.
	temp=$(echo $temp)
	IFS=$ifs
	digits=0

	for temp in $temp; do
	    version=${version}$(printf '%02d' $temp)
	    digits=$(($digits + 1))
	    [ $digits -eq 3 ] && break
	done
    fi

    echo $version

    VERBOSITY="$verbosity"
}

#
# Do required exports or create the required option string and run the passed script using
# $SHOREWALL_SHELL
#
run_it() {
    local script
    local options
    local version

    export VARDIR

    script=$1
    shift

    version=$(get_script_version $script)

    if [ $version -lt 040408 ]; then
	#
	# Old script that doesn't understand 4.4.8 script options
	#
	export RESTOREFILE
	export VERBOSITY
	export NOROUTES=$g_noroutes
	export PURGE=$g_purge
	export TIMESTAMP=$g_timestamp
	export RECOVERING=$g_recovering

	case "$g_program" in
	    *-lite)
		#
		# Shorewall Lite
		#
		export LOGFORMAT
		export IPTABLES
		;;
	esac
    else
	#
	# 4.4.8 or later -- no additional exports required
	#
	if [ x$1 = xtrace -o x$1 = xdebug ]; then
	    options="$1 -"
	    shift;
	else
	    options='-'
	fi

	[ -n "$g_noroutes" ]   && options=${options}n
	[ -n "$g_timestamp" ]  && options=${options}t
	[ -n "$g_purge" ]      && options=${options}p
	[ -n "$g_recovering" ] && options=${options}r

	options="${options}V $VERBOSITY"

	[ -n "$RESTOREFILE" ] && options="${options} -R $RESTOREFILE"
    fi

    $SHOREWALL_SHELL $script $options $@
}

#
# Message to stderr
#
error_message() # $* = Error Message
{
   echo "   $@" >&2
}

#
# Undo the effect of 'split()'
#
join()
{
    local f
    local o
    o=

    for f in $* ; do
        o="${o:+$o:}$f"
    done

    echo $o
}

#
# Return the number of elements in a list
#
list_count() # $* = list
{
    return $#
}

#
# Split a colon-separated list into a space-separated list
#
split() {
    local ifs
    ifs=$IFS
    IFS=:
    echo $*
    IFS=$ifs
}

#
# Search a list looking for a match -- returns zero if a match found
# 1 otherwise
#
list_search() # $1 = element to search for , $2-$n = list
{
    local e
    e=$1

    while [ $# -gt 1 ]; do
	shift
	[ "x$e" = "x$1" ] && return 0
    done

    return 1
}

#
# Suppress all output for a command
#
qt()
{
    "$@" >/dev/null 2>&1
}

#
# Suppress all output and input - mainly for preventing leaked file descriptors
# to avoid SELinux denials
#
qtnoin()
{
    "$@" </dev/null >/dev/null 2>&1
}

qt1()
{
    local status

    while [ 1 ]; do
	"$@" </dev/null >/dev/null 2>&1
	status=$?
	[ $status -ne 4 ] && return $status
    done
}

#
# Determine if Shorewall[6] is "running"
#
product_is_started() {
    qt1 $g_tool -L shorewall -n
}

shorewall_is_started() {
    qt1 $IPTABLES -L shorewall -n
}

shorewall6_is_started() {
    qt1 $IP6TABLES -L shorewall -n
}

#
# Echos the fully-qualified name of the calling shell program
#
my_pathname() {
    local pwd
    pwd=$PWD
    cd $(dirname $0)
    echo $PWD/$(basename $0)
    cd $pwd
}

#
# Source a user exit file if it exists
#
run_user_exit() # $1 = file name
{
    local user_exit
    user_exit=$(find_file $1)

    if [ -f $user_exit ]; then
	progress_message "Processing $user_exit ..."
	. $user_exit
    fi
}

#
# Load a Kernel Module -- assumes that the variable 'moduledirectories' contains
#                         a space-separated list of directories to search for
#                         the module and that 'moduleloader' contains the
#                         module loader command.
#
loadmodule() # $1 = module name, $2 - * arguments
{
    local modulename
    modulename=$1
    local modulefile
    local suffix

    if [ -d /sys/module/ ]; then
	if ! list_search $modulename $DONT_LOAD; then
	    if [ ! -d /sys/module/$modulename ]; then
		shift

		for suffix in $MODULE_SUFFIX ; do
		    for directory in $moduledirectories; do
			modulefile=$directory/${modulename}.${suffix}

			if [ -f $modulefile ]; then
			    case $moduleloader in
				insmod)
				    insmod $modulefile $*
				    ;;
				*)
				    modprobe $modulename $*
				    ;;
			    esac
			    break 2
			fi
		    done
		done
	    fi
	fi
    elif ! list_search $modulename $DONT_LOAD $MODULES; then
	shift

	for suffix in $MODULE_SUFFIX ; do
	    for directory in $moduledirectories; do
		modulefile=$directory/${modulename}.${suffix}

		if [ -f $modulefile ]; then
		    case $moduleloader in
			insmod)
			    insmod $modulefile $*
			    ;;
			*)
			    modprobe $modulename $*
			    ;;
		    esac
		    break 2
		fi
	    done
	done
    fi
}

#
# Reload the Modules
#
reload_kernel_modules() {

    local save_modules_dir
    save_modules_dir=$MODULESDIR
    local directory
    local moduledirectories
    moduledirectories=
    local moduleloader
    moduleloader=modprobe
    local uname

    if ! qt mywhich modprobe; then
	moduleloader=insmod
    fi

    [ -n "${MODULE_SUFFIX:=ko ko.gz o o.gz gz}" ]

    [ -z "$MODULESDIR" ] && \
	uname=$(uname -r) && \
	MODULESDIR=/lib/modules/$uname/kernel/net/ipv${g_family}/netfilter:/lib/modules/$uname/kernel/net/netfilter:/lib/modules/$uname/kernel/net/sched:/lib/modules/$uname/extra:/lib/modules/$uname/extra/ipset

    [ -d /sys/module/ ] || MODULES=$(lsmod | cut -d ' ' -f1)

    for directory in $(split $MODULESDIR); do
	[ -d $directory ] && moduledirectories="$moduledirectories $directory"
    done

    [ -n "$moduledirectories" ] && while read command; do
	eval $command
    done

    MODULESDIR=$save_modules_dir
}

#
# Load kernel modules required for Shorewall
#
load_kernel_modules() # $1 = Yes, if we are to save moduleinfo in $VARDIR
{
    local save_modules_dir
    save_modules_dir=$MODULESDIR
    local directory
    local moduledirectories
    moduledirectories=
    local moduleloader
    moduleloader=modprobe
    local savemoduleinfo
    savemoduleinfo=${1:-Yes} # So old compiled scripts still work
    local uname

    if ! qt mywhich modprobe; then
	moduleloader=insmod
    fi

    [ -n "${MODULE_SUFFIX:=o gz ko o.gz ko.gz}" ]

    [ -z "$MODULESDIR" ] && \
	uname=$(uname -r) && \
	MODULESDIR=/lib/modules/$uname/kernel/net/ipv${g_family}/netfilter:/lib/modules/$uname/kernel/net/netfilter:/lib/modules/$uname/kernel/net/sched:/lib/modules/$uname/extra:/lib/modules/$uname/extra/ipset

    for directory in $(split $MODULESDIR); do
	[ -d $directory ] && moduledirectories="$moduledirectories $directory"
    done

    [ -n "$LOAD_HELPERS_ONLY" ] && modules=$(find_file helpers) || modules=$(find_file modules)

    if [ -f $modules -a -n "$moduledirectories" ]; then
	[ -d /sys/module/ ] || MODULES=$(lsmod | cut -d ' ' -f1)
	progress_message "Loading Modules..."
	. $modules
	if [ $savemoduleinfo = Yes ]; then
	    [ -d ${VARDIR} ] || mkdir -p ${VARDIR}
	    echo MODULESDIR="$MODULESDIR" > ${VARDIR}/.modulesdir
	    cp -f $modules ${VARDIR}/.modules
	fi
    elif [ $savemoduleinfo = Yes ]; then
	[ -d ${VARDIR} ] || mkdir -p ${VARDIR}
	> ${VARDIR}/.modulesdir
	> ${VARDIR}/.modules
    fi

    MODULESDIR=$save_modules_dir
}

#
#  Note: The following set of IP address manipulation functions have anomalous
#        behavior when the shell only supports 32-bit signed arithmetic and
#        the IP address is 128.0.0.0 or 128.0.0.1.
#

LEFTSHIFT='<<'

#
# Convert an IP address in dot quad format to an integer
#
decodeaddr() {
    local x
    local temp
    temp=0
    local ifs
    ifs=$IFS

    IFS=.

    for x in $1; do
	temp=$(( $(( $temp $LEFTSHIFT 8 )) | $x ))
    done

    echo $temp

    IFS=$ifs
}

#
# convert an integer to dot quad format
#
encodeaddr() {
    addr=$1
    local x
    local y
    y=$(($addr & 255))

    for x in 1 2 3 ; do
	addr=$(($addr >> 8))
	y=$(($addr & 255)).$y
    done

    echo $y
}

#
# Netmask from CIDR
#
ip_netmask() {
    local vlsm
    vlsm=${1#*/}

    [ $vlsm -eq 0 ] && echo 0 || echo $(( -1 $LEFTSHIFT $(( 32 - $vlsm )) ))
}

#
# Network address from CIDR
#
ip_network() {
    local decodedaddr
    decodedaddr=$(decodeaddr ${1%/*})
    local netmask
    netmask=$(ip_netmask $1)

    echo $(encodeaddr $(($decodedaddr & $netmask)))
}

#
# The following hack is supplied to compensate for the fact that many of
# the popular light-weight Bourne shell derivatives don't support XOR ("^").
#
ip_broadcast() {
    local x
    x=$(( 32 - ${1#*/} ))

    [ $x -eq 32 ] && echo -1 || echo $(( $(( 1 $LEFTSHIFT $x )) - 1 ))
}

#
# Calculate broadcast address from CIDR
#
broadcastaddress() {
    local decodedaddr
    decodedaddr=$(decodeaddr ${1%/*})
    local netmask
    netmask=$(ip_netmask $1)
    local broadcast
    broadcast=$(ip_broadcast $1)

    echo $(encodeaddr $(( $(($decodedaddr & $netmask)) | $broadcast )))
}

#
# Test for network membership
#
in_network() # $1 = IP address, $2 = CIDR network
{
    local netmask
    netmask=$(ip_netmask $2)
    #
    # Use string comparison to work around a broken BusyBox ash in OpenWRT
    #
    test $(( $(decodeaddr $1) & $netmask)) = $(( $(decodeaddr ${2%/*}) & $netmask ))
}

#
# Query NetFilter about the existence of a filter chain
#
chain_exists() # $1 = chain name
{
    qt1 $g_tool -L $1 -n
}

#
# Find the interface with the passed MAC address
#

find_interface_by_mac() {
    local mac
    mac=$1
    local first
    local second
    local rest
    local dev

    $IP link list | while read first second rest; do
	case $first in
	    *:)
                dev=$second
		;;
	    *)
	        if [ "$second" = $mac ]; then
		    echo ${dev%:}
		    return
		fi
	esac
    done
}

#
# Find interface address--returns the first IP address assigned to the passed
# device
#
find_first_interface_address() # $1 = interface
{
    if [ $g_family -eq 4 ]; then
	#
	# get the line of output containing the first IP address
	#
	addr=$(${IP:-ip} -f inet addr show $1 2> /dev/null | grep 'inet .* global' | head -n1)
	#
	# If there wasn't one, bail out now
	#
	[ -n "$addr" ] || startup_error "Can't determine the IP address of $1"
	#
	# Strip off the trailing VLSM mask (or the peer IP in case of a P-t-P link)
	# along with everything else on the line
	#
	echo $addr | sed 's/\s*inet //;s/\/.*//;s/ peer.*//'
    else
	#
	# get the line of output containing the first IP address
	#
	addr=$(${IP:-ip} -f inet6 addr show dev $1 2> /dev/null | grep -F 'inet6 ' | grep -vF 'scope link' | head -n1)
	#
	# If there wasn't one, bail out now
	#
	[ -n "$addr" ] || startup_error "Can't determine the IPv6 address of $1"
	#
	# Strip off the trailing VLSM mask (or the peer IP in case of a P-t-P link)
	# along with everything else on the line
	#
	echo $addr | sed 's/\s*inet6 //;s/\/.*//;s/ peer.*//'
    fi
}

find_first_interface_address_if_any() # $1 = interface
{
    if [ $g_family -eq 4 ]; then
	#
	# get the line of output containing the first IP address
	#
	addr=$(${IP:-ip} -f inet addr show $1 2> /dev/null | grep 'inet .* global' | head -n1)
	#
	# Strip off the trailing VLSM mask (or the peer IP in case of a P-t-P link)
	# along with everything else on the line
	#
	[ -n "$addr" ] && echo $addr | sed 's/\s*inet //;s/\/.*//;s/ peer.*//' || echo 0.0.0.0
    else
	#
	# get the line of output containing the first IP address
	#
	addr=$(${IP:-ip} -f inet6 addr show dev $1 2> /dev/null | grep -F 'inet6 ' | grep -vF 'scope link' | head -n1)
	#
	# Strip off the trailing VLSM mask (or the peer IP in case of a P-t-P link)
	# along with everything else on the line
	#
	[ -n "$addr" ] && echo $addr | sed 's/\s*inet6 //;s/\/.*//;s/ peer.*//' || echo ::
    fi
}

#
# Internal version of 'which'
#
mywhich() {
    local dir

    for dir in $(split $PATH); do
	if [ -x $dir/$1 ]; then
	    echo $dir/$1
	    return 0
	fi
    done

    return 2
}

#
# Find a File -- For relative file name, look in each ${CONFIG_PATH} then ${CONFDIR}
#
find_file()
{
    local saveifs
    saveifs=
    local directory

    case $1 in
	/*)
	    echo $1
	    ;;
	*)
	    for directory in $(split $CONFIG_PATH); do
		if [ -f $directory/$1 ]; then
		    echo $directory/$1
		    return
		fi
	    done

	    if [ -n "$g_shorewalldir" ]; then
		echo ${g_shorewalldir}/$1
	    else
		echo ${g_confdir}/$1
	    fi
	    ;;
    esac
}

#
# Set the Shorewall state
#
set_state () # $1 = state
{
    if [ $# -gt 1 ]; then
	echo "$1 ($(date)) from $2" > ${VARDIR}/state
    else
	echo "$1 ($(date))" > ${VARDIR}/state
    fi
}

#
# Perform variable substitution on the passed argument and echo the result
#
expand() # $@ = contents of variable which may be the name of another variable
{
    eval echo \"$@\"
}

#
# Function for including one file into another
#
INCLUDE() {
    . $(find_file $(expand $@))
}

# Function to truncate a string -- It uses 'cut -b -<n>'
# rather than ${v:first:last} because light-weight shells like ash and
# dash do not support that form of expansion.
#

truncate() # $1 = length
{
    cut -b -${1}
}

#
# Call this function to assert mutual exclusion with Shorewall. If you invoke the
# /sbin/shorewall program while holding mutual exclusion, you should pass "nolock" as
# the first argument. Example "shorewall nolock refresh"
#
# This function uses the lockfile utility from procmail if it exists.
# Otherwise, it uses a somewhat race-prone algorithm to attempt to simulate the
# behavior of lockfile.
#
mutex_on()
{
    local try
    try=0
    local lockf
    # lockf=${LOCKFILE:=${VARDIR}/lock}
    local lockf=/var/lock/$g_product
    local lockpid

    MUTEX_TIMEOUT=${MUTEX_TIMEOUT:-60}

    if [ $MUTEX_TIMEOUT -gt 0 ]; then

	[ -d ${VARDIR} ] || mkdir -p ${VARDIR}

	if [ -f $lockf ]; then
	    lockpid=`cat ${lockf} 2> /dev/null`
	    if [ -z "$lockpid" -o $lockpid = 0 ]; then
		rm -f ${lockf}
		error_message "WARNING: Stale lockfile ${lockf} removed"
	    elif [ $lockpid -eq $$ ]; then
                return 0
	    elif ! qt ps p ${lockpid}; then
		rm -f ${lockf}
		error_message "WARNING: Stale lockfile ${lockf} from pid ${lockpid} removed"
	    fi
	fi

	if qt mywhich lockfile; then
	    lockfile -${MUTEX_TIMEOUT} -r1 ${lockf}
	    chmod u+w ${lockf}
	    echo $$ > ${lockf}
	    chmod u-w ${lockf}
	else
	    while [ -f ${lockf} -a ${try} -lt ${MUTEX_TIMEOUT} ] ; do
		sleep 1
		try=$((${try} + 1))
	    done

	    if  [ ${try} -lt ${MUTEX_TIMEOUT} ] ; then
	        # Create the lockfile
		echo $$ > ${lockf}
	    else
		echo "Giving up on lock file ${lockf}" >&2
	    fi
	fi
    fi
}

#
# Call this function to release mutual exclusion
#
mutex_off()
{
    # rm -f ${LOCKFILE:=${VARDIR}/lock}
    rm -f /var/lock/$g_product
}

################################################################################
#   End of imports from /usr/share/shorewall//lib.common
################################################################################
################################################################################
# Functions to execute the various user exits (extension scripts)
################################################################################

run_init_exit() {
    
    progress_message2 Processing init user exit ...

    #
    # Shorewall version 4 - Init File
    #
    # /etc/shorewall/init
    #
    #	Add commands below that you want to be executed at the beginning of
    #	a "shorewall start" or "shorewall restart" command.
    #
    # For additional information, see
    # http://shorewall.net/shorewall_extension_scripts.htm
    #
    ###############################################################################
}

run_start_exit() {
    
    progress_message2 Processing start user exit ...

    #
    # Shorewall version 4 - Start File
    #
    # /etc/shorewall/start
    #
    #	Add commands below that you want to be executed after shorewall has
    #	been started or restarted.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
    return 0
}

run_tcclear_exit() {
    
    progress_message2 Processing tcclear user exit ...

    #
    # Shorewall version 4 - tcclear File
    #
    # /etc/shorewall/tcclear
    #
    #	Add commands below that you want to be executed before Shorewall
    #       clears the traffic shaping configuration.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_started_exit() {
    
    progress_message2 Processing started user exit ...

    #
    # Shorewall version 4 - Started File
    #
    # /etc/shorewall/started
    #
    #	Add commands below that you want to be executed after shorewall has
    #	been completely started or restarted. The difference between this
    #	extension script and /etc/shorewall/start is that this one is invoked
    #	after delayed loading of the blacklist (DELAYBLACKLISTLOAD=Yes) and
    #	after the 'shorewall' chain has been created (thus signaling that the
    #	firewall is completely up).
    #
    #	This script should not change the firewall configuration directly but
    #	may do so indirectly by running /sbin/shorewall with the 'nolock'
    #	option.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_stop_exit() {
    
    progress_message2 Processing stop user exit ...

    #
    # Shorewall version 4 - Stop File
    #
    # /etc/shorewall/stop
    #
    #	Add commands below that you want to be executed at the beginning of a
    #	"shorewall stop" command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_stopped_exit() {
    
    progress_message2 Processing stopped user exit ...

    #
    # Shorewall version 4 - Stopped File
    #
    # /etc/shorewall/stopped
    #
    #	Add commands below that you want to be executed at the completion of a
    #	"shorewall stop" command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_clear_exit() {
    
    progress_message2 Processing clear user exit ...

    #
    # Shorewall version 4 - clear File
    #
    # /etc/shorewall/clear
    #
    #	Add commands below that you want to be executed after Shorewall
    #       has processed the 'clear' command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_refresh_exit() {
    
    progress_message2 Processing refresh user exit ...

    #
    # Shorewall version 4 - refresh File
    #
    # /etc/shorewall/refresh
    #
    #	Add commands below that you want to be executed before Shorewall
    #       has processed the 'refresh' command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_refreshed_exit() {
    
    progress_message2 Processing refreshed user exit ...

    #
    # Shorewall version 4 - refreshed File
    #
    # /etc/shorewall/refreshed
    #
    #	Add commands below that you want to be executed after Shorewall
    #       has processed the 'refresh' command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_restored_exit() {
    
    progress_message2 Processing restored user exit ...

    #
    # Shorewall version 4 - Restored File
    #
    # /etc/shorewall/restored
    #
    #	Add commands below that you want to be executed after shorewall has
    #	completed a 'restore' command.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
}

run_isusable_exit() {
    #
    # Shorewall version 4 - isusable File
    #
    # /etc/shorewall/isusable
    #
    #	This script is called when Shorewall is attempting to determine
    #	if an interface named in /etc/shorewall/providers is usable.
    #
    #	The script is invoked inside a function that accepts an interface
    #	name as a single argument. The file below is designed to work with
    #	both swping and lsm as described at
    #	http://www.shorewall.net/MultiISP.html
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
    local status
    status=0

    [ -f ${VARDIR}/${1}.status ] && status=$(cat ${VARDIR}/${1}.status)

    return $status
}

run_findgw_exit() {
    #
    # Shorewall version 4 - Findgw File
    #
    # /etc/shorewall/findgw
    #
    #    The code in this file is executed when Shorewall is trying to detect the
    #    gateway through an interface in /etc/shorewall/providers that has GATEWAY
    #    specified as 'detect'.
    #
    #    The function should echo the IP address of the gateway if it knows what
    #    it is; the name of the interface is in $1.
    #
    # See http://shorewall.net/shorewall_extension_scripts.htm for additional
    # information.
    #
    ###############################################################################
    true
}
################################################################################
# End user exit functions
################################################################################

#
# Setup Common Rules (/proc)
#
setup_common_rules() {
    
    progress_message2 Setting up Route Filtering...

    for file in /proc/sys/net/ipv4/conf/*; do
	[ -f $file/rp_filter ] && echo 0 > $file/rp_filter
    done

    if [ -f /proc/sys/net/ipv4/conf/eth0/rp_filter ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth0/rp_filter
    else
	error_message "WARNING: Cannot set route filtering on eth0"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth1/rp_filter ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth1/rp_filter
    else
	error_message "WARNING: Cannot set route filtering on eth1"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth2/rp_filter ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth2/rp_filter
    else
	error_message "WARNING: Cannot set route filtering on eth2"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth3/rp_filter ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth3/rp_filter
    else
	error_message "WARNING: Cannot set route filtering on eth3"
    fi

    echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
    echo 0 > /proc/sys/net/ipv4/conf/default/rp_filter
    [ -n "$g_noroutes" ] || $IP -4 route flush cache
    
    progress_message2 Setting up Martian Logging...

    for file in /proc/sys/net/ipv4/conf/*; do
	[ -f $file/log_martians ] && echo 1 > $file/log_martians
    done

    echo 0 > /proc/sys/net/ipv4/conf/all/log_martians

    if [ -f /proc/sys/net/ipv4/conf/eth0/log_martians ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth0/log_martians
    else
	error_message "WARNING: Cannot set Martian logging on eth0"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth1/log_martians ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth1/log_martians
    else
	error_message "WARNING: Cannot set Martian logging on eth1"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth2/log_martians ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth2/log_martians
    else
	error_message "WARNING: Cannot set Martian logging on eth2"
    fi

    if [ -f /proc/sys/net/ipv4/conf/eth3/log_martians ]; then
	echo 1 > /proc/sys/net/ipv4/conf/eth3/log_martians
    else
	error_message "WARNING: Cannot set Martian logging on eth3"
    fi

    progress_message2 Setting up Proxy ARP...

    #
    # Disable automatic helper association on kernel 3.5.0 and later
    #
    if [ -f /proc/sys/net/netfilter/nf_conntrack_helper ]; then
	progress_message "Disabling Kernel Automatic Helper Association"
	echo 0 > /proc/sys/net/netfilter/nf_conntrack_helper
    fi

    return 0
}

#
# Add Provider ISP1 (1)
#
start_provider_ISP1() {
    if interface_is_usable eth2 && [ -n "$SW_ETH2_ISP1_MAC" ]; then
	qt ip -4 route flush table 1
	echo "$IP -4 route flush table 1 > /dev/null 2>&1" > ${VARDIR}/undo_ISP1_routing

	cat <<EOF >> ${VARDIR}/undo_ISP1_routing
case \$COMMAND in
    enable|disable)
        ;;
    *)
        rm -f ${VARDIR}/eth2.status
        ;;
esac
EOF
	if [ $COMMAND = enable ]; then
	    echo 1 > /proc/sys/net/ipv4/conf/eth2/rp_filter
	    echo 1 > /proc/sys/net/ipv4/conf/eth2/log_martians
	fi

	qt $IP -4 rule del fwmark 0x10000/0xff0000
	run_ip rule add fwmark 0x10000/0xff0000 pref 10000 table 1
	echo "$IP -4 rule del fwmark 0x10000/0xff0000 > /dev/null 2>&1" >> ${VARDIR}/undo_ISP1_routing

	$IP -4 -o route show table main | sed -r 's/ realm [[:alnum:]]+//' | while read net route; do
	    case $net in
		default)
		    ;;
		*)
		    case $(find_device $route) in
			eth2|eth0|eth1)
			    case $net in
				255.255.255.255*)
				    ;;
				*)
				    run_ip route add table 1 $net $route realm 1
				    ;;
			    esac
			    ;;
		    esac
		    ;;
	    esac
	done

#
# Add Provider ISP2 (2)
#
start_provider_ISP2() {
    if interface_is_usable eth3 && [ -n "$SW_ETH3_ISP2_MAC" ]; then
	qt ip -4 route flush table 2
	echo "$IP -4 route flush table 2 > /dev/null 2>&1" > ${VARDIR}/undo_ISP2_routing

	cat <<EOF >> ${VARDIR}/undo_ISP2_routing
case \$COMMAND in
    enable|disable)
        ;;
    *)
        rm -f ${VARDIR}/eth3.status
        ;;
esac
EOF
	if [ $COMMAND = enable ]; then
	    echo 1 > /proc/sys/net/ipv4/conf/eth3/rp_filter
	    echo 1 > /proc/sys/net/ipv4/conf/eth3/log_martians
	fi

	qt $IP -4 rule del fwmark 0x20000/0xff0000
	run_ip rule add fwmark 0x20000/0xff0000 pref 10001 table 2
	echo "$IP -4 rule del fwmark 0x20000/0xff0000 > /dev/null 2>&1" >> ${VARDIR}/undo_ISP2_routing

	$IP -4 -o route show table main | sed -r 's/ realm [[:alnum:]]+//' | while read net route; do
	    case $net in
		default)
		    ;;
		*)
		    case $(find_device $route) in
			eth3|eth0|eth1)
			    case $net in
				255.255.255.255*)
				    ;;
				*)
				    run_ip route add table 2 $net $route realm 2
				    ;;
			    esac
			    ;;
		    esac
		    ;;
	    esac
	done

	echo 0 > ${VARDIR}/eth3.status
	progress_message "Provider ISP2 (2) Started"
    else
	echo 1 > ${VARDIR}/eth3.status
    fi
} # End of start_provider_ISP2();

#
# Enable an optional provider
#
enable_provider() {
    g_interface=$1;

    case $g_interface in

	*)
	    startup_error "$g_interface is not an optional provider or interface"
	    ;;
    esac

}

#
# Disable an optional provider
#
disable_provider() {
    g_interface=$1;

    case $g_interface in

	*)
	    startup_error "$g_interface is not an optional provider interface"
	    ;;
    esac
}

#
# Setup routing and traffic shaping
#
setup_routing_and_traffic_shaping() {
    
    if [ -z "$g_noroutes" ]; then
	#
	# Undo any changes made since the last time that we [re]started -- this will not restore the default route
	#
	undo_routing
	
	#
	# Update the routing table database
	#
	if [ -w /etc/iproute2/rt_tables ]; then
	    cat > /etc/iproute2/rt_tables <<EOF
#
# reserved values
#
255	local
254	main
253	default
0	unspec
#
# local
#
1	ISP1
2	ISP2
EOF

	fi

	#
	# Capture the default route(s) if we don't have it (them) already.
	#
	[ -f ${VARDIR}/default_route ] || $IP -4 route list | save_default_route > ${VARDIR}/default_route
	
	progress_message2 Adding Providers...

	DEFAULT_ROUTE=
	FALLBACK_ROUTE=

	> ${VARDIR}/undo_main_routing 

	> ${VARDIR}/undo_default_routing 

	start_provider_ISP1
	start_provider_ISP2

	if [ -n "$DEFAULT_ROUTE" ]; then
	    run_ip route replace default scope global table 254 $DEFAULT_ROUTE
	    progress_message "Default route '$(echo $DEFAULT_ROUTE | sed 's/$\s*//')' Added"
	else
	    error_message "WARNING: No Default route added (all 'balance' providers are down)"
	    restore_default_route  && error_message "NOTICE: Default route restored"
	fi

	run_ip route flush cache
    fi

}

#
# This function initializes the global variables used by the program
#
initialize()
{
    #
    # Be sure that umask is sane
    #
    umask 077

    #
    # These variables are required by the library functions called in this script
    #
    g_family=4
    g_confdir=/etc/shorewall-lite
    g_product="Shorewall Lite"
    g_program=shorewall-lite
    g_basedir=/usr/share/shorewall-lite
    CONFIG_PATH="/etc/shorewall-lite:/usr/share/shorewall-lite"
    [ -f ${g_confdir}/vardir ] && . ${g_confdir}/vardir
    [ -n "${VARDIR:=/var/lib/shorewall-lite}" ]
    [ -n "${VARLIB:=/var/lib}" ]
    TEMPFILE=
    DISABLE_IPV6=""
    MODULESDIR=""
    MODULE_SUFFIX="ko"
    LOAD_HELPERS_ONLY=""
    SUBSYSLOCK=""
    LOG_VERBOSITY="2"
    [ -n "${COMMAND:=restart}" ]
    [ -n "${VERBOSITY:=0}" ]
    [ -n "${RESTOREFILE:=restore}" ]
    SHOREWALL_VERSION="4.5.21.6"
    PATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin"
    TERMINATOR=fatal_error
    DONT_LOAD=""
    STARTUP_LOG="/var/log/shorewall-lite-init.log"

    [ -z "$IPTABLES" ] && IPTABLES=$(mywhich iptables) # /sbin/shorewall exports IPTABLES
    [ -n "$IPTABLES" -a -x "$IPTABLES" ] || startup_error "Can't find iptables executable"

    case $IPTABLES in
	*/*)
	    ;;
	*)
	    IPTABLES=./$IPTABLES
	    ;;
    esac

    IP6TABLES=${IPTABLES%/*}/ip6tables
    IPTABLES_RESTORE=${IPTABLES}-restore
    [ -x "$IPTABLES_RESTORE" ] || startup_error "$IPTABLES_RESTORE does not exist or is not executable"
    g_tool=$IPTABLES
    IP=ip
    TC=tc
    IPSET=ipset
    #
    # From the params file
    #
    DMZ1_IF=eth1
    ISP1_IF=eth2
    ISP2_IF=eth3

    g_stopping=

    #
    # The library requires that ${VARDIR} exist
    #
    [ -d ${VARDIR} ] || mkdir -p ${VARDIR}

}

#
# Set global variables holding detected IP information
#
detect_configuration()
{
    case $COMMAND in
	start|restart|refresh|disable|enable)


	    ;;
    esac

}

#
# Create the input to iptables-restore/ip6tables-restore and pass that input to the utility
#
setup_netfilter()
{
    
    progress_message2 Preparing iptables-restore input...

    exec 3>${VARDIR}/.iptables-restore-input

    cat >&3 << __EOF__
#
# Generated by Shorewall 4.5.21.6 - Wed Mar 18 15:36:10 2015
#
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
*nat
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:TransIP - [0:0]
:eth2_masq - [0:0]
:eth3_masq - [0:0]
:net_dnat - [0:0]
-A PREROUTING -i eth2 -j net_dnat
-A PREROUTING -i eth3 -j net_dnat
-A POSTROUTING -s 10.101.0.0/16 -j TransIP
-A POSTROUTING -o eth2 -j eth2_masq
-A POSTROUTING -o eth3 -j eth3_masq
-A eth2_masq -s 10.50.10.0/24 -m realm --realm 1 -j MASQUERADE
-A eth3_masq -s 10.0.82.200 -m realm --realm 2 -j MASQUERADE
-A eth3_masq -s 10.0.0.0/16 -m realm --realm 2 -j MASQUERADE
COMMIT
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:routemark - [0:0]
:tcfor - [0:0]
:tcin - [0:0]
:tcout - [0:0]
:tcpost - [0:0]
:tcpre - [0:0]
-A PREROUTING -j CONNMARK --restore-mark --mask 0xff0000
-A PREROUTING -i eth2 -m mark --mark 0/0xff0000 -j routemark
-A PREROUTING -i eth3 -m mark --mark 0/0xff0000 -j routemark
-A PREROUTING -i eth2 -j tcpre
-A PREROUTING -i eth3 -j tcpre
-A PREROUTING -m mark --mark 0/0xff0000 -j tcpre
-A INPUT -j tcin
-A FORWARD -j MARK --set-mark 0/0xff0000
-A FORWARD -j tcfor
-A OUTPUT -j CONNMARK --restore-mark --mask 0xff0000
-A OUTPUT -m mark --mark 0/0xff0000 -j tcout
-A POSTROUTING -j tcpost
-A routemark -i eth2 -m mac --mac-source $SW_ETH2_ISP1_MAC -j MARK --set-mark 0x10000/0xff0000
-A routemark -i eth3 -m mac --mac-source $SW_ETH3_ISP2_MAC -j MARK --set-mark 0x20000/0xff0000
-A routemark -m mark ! --mark 0/0xff0000 -j CONNMARK --save-mark --mask 0xff0000
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
:Broadcast - [0:0]
:Drop - [0:0]
:dmz12fw - [0:0]
:dmz12loc - [0:0]
:dmz12net - [0:0]
:dmz1_frwd - [0:0]
:dynamic - [0:0]
:eth2_fwd - [0:0]
:eth2_in - [0:0]
:eth3_fwd - [0:0]
:eth3_in - [0:0]
:fw2dmz1 - [0:0]
:fw2loc - [0:0]
:fw2net - [0:0]
:loc2dmz1 - [0:0]
:loc2fw - [0:0]
:loc2net - [0:0]
:loc_frwd - [0:0]
:logdrop - [0:0]
:logflags - [0:0]
:logreject - [0:0]
:net2dmz1 - [0:0]
:net2fw - [0:0]
:net2loc - [0:0]
:net2net - [0:0]
:net_frwd - [0:0]
:reject - [0:0]
:smurflog - [0:0]
:smurfs - [0:0]
:tcpflags - [0:0]
-A INPUT -i eth0 -j loc2fw
-A INPUT -i eth1 -j dmz12fw
-A INPUT -i eth2 -j eth2_in
-A INPUT -i eth3 -j eth3_in
-A INPUT -i lo -j ACCEPT
-A INPUT -j LOG --log-level 6 --log-prefix "Shorewall:INPUT:ACCEPT:"
-A INPUT -j ACCEPT
-A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-A FORWARD -i eth0 -j loc_frwd
-A FORWARD -i eth1 -j dmz1_frwd
-A FORWARD -i eth2 -j eth2_fwd
-A FORWARD -i eth3 -j eth3_fwd
-A FORWARD -j LOG --log-level 6 --log-prefix "Shorewall:FORWARD:ACCEPT:"
-A FORWARD -j ACCEPT
-A OUTPUT -o eth0 -j fw2loc
-A OUTPUT -o eth1 -j fw2dmz1
-A OUTPUT -o eth2 -j fw2net
-A OUTPUT -o eth3 -j fw2net
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -j ACCEPT
-A Broadcast -m addrtype --dst-type BROADCAST -j DROP
-A Broadcast -m addrtype --dst-type MULTICAST -j DROP
-A Broadcast -m addrtype --dst-type ANYCAST -j DROP
-A Drop
-A Drop -j Broadcast
-A Drop -p 1 --icmp-type 3/4 -j ACCEPT -m comment --comment "Needed ICMP types"
-A Drop -p 1 --icmp-type 11 -j ACCEPT -m comment --comment "Needed ICMP types"
-A Drop -m conntrack --ctstate INVALID -j DROP
-A Drop -p 17 -m multiport --dports 135,445 -j DROP -m comment --comment "SMB"
-A Drop -p 17 --dport 137:139 -j DROP -m comment --comment "SMB"
-A Drop -p 17 --dport 1024:65535 --sport 137 -j DROP -m comment --comment "SMB"
-A Drop -p 6 -m multiport --dports 135,139,445 -j DROP -m comment --comment "SMB"
-A Drop -p 17 --dport 1900 -j DROP -m comment --comment "UPnP"
-A Drop -p 6 ! --syn -j DROP
-A Drop -p 17 --sport 53 -j DROP -m comment --comment "Late DNS Replies"
-A dmz12fw -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A dmz12fw -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A dmz12fw -p udp --dport 67:68 -j ACCEPT
-A dmz12fw -p tcp -j tcpflags
-A dmz12fw -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A dmz12fw -j LOG --log-level 6 --log-prefix "Shorewall:dmz12fw:ACCEPT:"
-A dmz12fw -j ACCEPT
-A dmz12loc -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A dmz12loc -j LOG --log-level 6 --log-prefix "Shorewall:dmz12loc:ACCEPT:"
-A dmz12loc -j ACCEPT
-A dmz12net -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A dmz12net -j LOG --log-level 6 --log-prefix "Shorewall:dmz12net:ACCEPT:"
-A dmz12net -j ACCEPT
-A dmz1_frwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A dmz1_frwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A dmz1_frwd -p tcp -j tcpflags
-A dmz1_frwd -o eth0 -j dmz12loc
-A dmz1_frwd -o eth1 -j ACCEPT
-A dmz1_frwd -o eth2 -j dmz12net
-A dmz1_frwd -o eth3 -j dmz12net
__EOF__

    [ -f ${VARDIR}/.dynamic ] && cat ${VARDIR}/.dynamic >&3

    cat >&3 << __EOF__
-A eth2_fwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A eth2_fwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A eth2_fwd -p tcp -j tcpflags
-A eth2_fwd -j net_frwd
-A eth2_in -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A eth2_in -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A eth2_in -p tcp -j tcpflags
-A eth2_in -j net2fw
-A eth3_fwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A eth3_fwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A eth3_fwd -p tcp -j tcpflags
-A eth3_fwd -j net_frwd
-A eth3_in -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A eth3_in -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A eth3_in -p tcp -j tcpflags
-A eth3_in -j net2fw
-A fw2dmz1 -p udp --dport 67:68 -j ACCEPT
-A fw2dmz1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A fw2dmz1 -j ACCEPT
-A fw2loc -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A fw2loc -j ACCEPT
-A fw2net -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A fw2net -j ACCEPT
-A loc2dmz1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A loc2dmz1 -j ACCEPT
-A loc2fw -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A loc2fw -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A loc2fw -p tcp -j tcpflags
-A loc2fw -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A loc2fw -j ACCEPT
-A loc2net -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A loc2net -j ACCEPT
-A loc_frwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j dynamic
-A loc_frwd -m conntrack --ctstate NEW,INVALID,UNTRACKED -j smurfs
-A loc_frwd -p tcp -j tcpflags
-A loc_frwd -o eth0 -j ACCEPT
-A loc_frwd -o eth1 -j loc2dmz1
-A loc_frwd -o eth2 -j loc2net
-A loc_frwd -o eth3 -j loc2net
-A logdrop -j DROP
-A logflags -j LOG --log-ip-options --log-level 6 --log-prefix "Shorewall:logflags:DROP:"
-A logflags -j DROP
-A logreject -j reject
-A net2dmz1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A net2dmz1 -d 224.0.0.0/4 -j RETURN
-A net2dmz1 -j Drop
-A net2dmz1 -j DROP
-A net2fw -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A net2fw -p 1 --icmp-type 8 -j ACCEPT -m comment --comment "Ping"
-A net2fw -d 224.0.0.0/4 -j RETURN
-A net2fw -j Drop
-A net2fw -j DROP
-A net2loc -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A net2loc -d 224.0.0.0/4 -j RETURN
-A net2loc -j Drop
-A net2loc -j DROP
-A net2net -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A net2net -d 224.0.0.0/4 -j RETURN
-A net2net -j Drop
-A net2net -j DROP
-A net_frwd -o eth0 -j net2loc
-A net_frwd -o eth1 -j net2dmz1
-A net_frwd -o eth2 -j net2net
-A net_frwd -o eth3 -j net2net
-A reject -m addrtype --src-type BROADCAST -j DROP
-A reject -s 224.0.0.0/4 -j DROP
-A reject -p 2 -j DROP
-A reject -p 6 -j REJECT --reject-with tcp-reset
-A reject -p 17 -j REJECT
-A reject -p 1 -j REJECT --reject-with icmp-host-unreachable
-A reject -j REJECT --reject-with icmp-host-prohibited
-A smurflog -j LOG --log-level 6 --log-prefix "Shorewall:smurfs:DROP:"
-A smurflog -j DROP
-A smurfs -s 0.0.0.0 -j RETURN
-A smurfs -m addrtype --src-type BROADCAST -g smurflog
-A smurfs -s 224.0.0.0/4 -g smurflog
-A tcpflags -p tcp --tcp-flags ALL FIN,URG,PSH -g logflags
-A tcpflags -p tcp --tcp-flags ALL NONE -g logflags
-A tcpflags -p tcp --tcp-flags SYN,RST SYN,RST -g logflags
-A tcpflags -p tcp --tcp-flags SYN,FIN SYN,FIN -g logflags
-A tcpflags -p tcp --syn --sport 0 -g logflags
COMMIT
__EOF__

    exec 3>&-

    [ -n "$g_debug_iptables" ] && command=debug_restore_input || command=$IPTABLES_RESTORE

    progress_message2 "Running $command..."

    cat ${VARDIR}/.iptables-restore-input | $command # Use this nonsensical form to appease SELinux
    if [ $? != 0 ]; then
	fatal_error "iptables-restore Failed. Input is in ${VARDIR}/.iptables-restore-input"
    fi

}

chainlist_reload()
{
    true
}

#
# Start/Restart the Firewall
#
define_firewall() {
    
    progress_message2 Initializing...

    echo MODULESDIR="$MODULESDIR" > ${VARDIR}/.modulesdir
    cat > ${VARDIR}/.modules << EOF
loadmodule nfnetlink
loadmodule x_tables
loadmodule ip_tables
loadmodule iptable_filter
loadmodule iptable_mangle
loadmodule ip_conntrack
loadmodule nf_conntrack
loadmodule nf_conntrack_ipv4
loadmodule iptable_nat
loadmodule iptable_raw
loadmodule xt_state
loadmodule xt_tcpudp
loadmodule ipt_LOG
loadmodule xt_AUDIT
loadmodule xt_CLASSIFY
loadmodule xt_connmark
loadmodule xt_CONNMARK
loadmodule xt_conntrack
loadmodule xt_dccp
loadmodule xt_dscp
loadmodule xt_DSCP
loadmodule xt_hashlimit
loadmodule xt_helper
loadmodule xt_ipp2p
loadmodule xt_iprange
loadmodule xt_length
loadmodule xt_limit
loadmodule xt_mac
loadmodule xt_mark
loadmodule xt_MARK
loadmodule xt_multiport
loadmodule xt_NFLOG
loadmodule xt_NFQUEUE
loadmodule xt_owner
loadmodule xt_physdev
loadmodule xt_pkttype
loadmodule xt_policy
loadmodule xt_sctp
loadmodule xt_tcpmss
loadmodule xt_TCPMSS
loadmodule xt_time
loadmodule xt_IPMARK
loadmodule xt_TPROXY
loadmodule xt_condition
loadmodule xt_geoip
loadmodule xt_ipp2p
loadmodule xt_LOGMARK
loadmodule xt_RAWNAT
loadmodule ip_conntrack_amanda
loadmodule ip_conntrack_ftp
loadmodule ip_conntrack_h323
loadmodule ip_conntrack_irc
loadmodule ip_conntrack_netbios_ns
loadmodule ip_conntrack_pptp
loadmodule ip_conntrack_sip
loadmodule ip_conntrack_tftp
loadmodule ip_nat_amanda
loadmodule ip_nat_ftp
loadmodule ip_nat_h323
loadmodule ip_nat_irc
loadmodule ip_nat_pptp
loadmodule ip_nat_sip
loadmodule ip_nat_snmp_basic
loadmodule ip_nat_tftp
loadmodule nf_conntrack_ftp
loadmodule nf_conntrack_h323
loadmodule nf_conntrack_irc
loadmodule nf_conntrack_netbios_ns
loadmodule nf_conntrack_netlink
loadmodule nf_conntrack_pptp
loadmodule nf_conntrack_proto_gre
loadmodule nf_conntrack_proto_sctp
loadmodule nf_conntrack_proto_udplite
loadmodule nf_conntrack_sip         sip_direct_media=0
loadmodule nf_conntrack_tftp
loadmodule nf_conntrack_sane
loadmodule nf_nat_amanda
loadmodule nf_nat_ftp
loadmodule nf_nat_h323
loadmodule nf_nat_irc
loadmodule nf_nat
loadmodule nf_nat_pptp
loadmodule nf_nat_proto_gre
loadmodule nf_nat_sip
loadmodule nf_nat_snmp_basic
loadmodule nf_nat_tftp
loadmodule xt_set
loadmodule ip_set
loadmodule ip_set_iphash
loadmodule ip_set_ipmap
loadmodule ip_set_ipporthash
loadmodule ip_set_iptree
loadmodule ip_set_iptreemap
loadmodule ip_set_macipmap
loadmodule ip_set_nethash
loadmodule ip_set_portmap
loadmodule ipt_SET
loadmodule ipt_set
loadmodule sch_sfq
loadmodule sch_ingress
loadmodule sch_hfsc
loadmodule sch_htb
loadmodule sch_prio
loadmodule sch_tbf
loadmodule sch_fq_codel
loadmodule cls_u32
loadmodule cls_fw
loadmodule cls_flow
loadmodule cls_basic
loadmodule act_police
loadmodule ipt_addrtype
loadmodule ipt_ah
loadmodule ipt_CLASSIFY
loadmodule ipt_CLUSTERIP
loadmodule ipt_comment
loadmodule ipt_connmark
loadmodule ipt_CONNMARK
loadmodule ipt_conntrack
loadmodule ipt_dscp
loadmodule ipt_DSCP
loadmodule ipt_ecn
loadmodule ipt_ECN
loadmodule ipt_esp
loadmodule ipt_hashlimit
loadmodule ipt_helper
loadmodule ipt_ipp2p
loadmodule ipt_iprange
loadmodule ipt_length
loadmodule ipt_limit
loadmodule ipt_LOG
loadmodule ipt_mac
loadmodule ipt_mark
loadmodule ipt_MARK
loadmodule ipt_MASQUERADE
loadmodule ipt_multiport
loadmodule ipt_NETMAP
loadmodule ipt_NOTRACK
loadmodule ipt_owner
loadmodule ipt_physdev
loadmodule ipt_pkttype
loadmodule ipt_policy
loadmodule ipt_realm
loadmodule ipt_recent
loadmodule ipt_REDIRECT
loadmodule ipt_REJECT
loadmodule ipt_SAME
loadmodule ipt_sctp
loadmodule ipt_set
loadmodule ipt_state
loadmodule ipt_tcpmss
loadmodule ipt_TCPMSS
loadmodule ipt_tos
loadmodule ipt_TOS
loadmodule ipt_ttl
loadmodule ipt_TTL
loadmodule ipt_ULOG
EOF

    reload_kernel_modules < ${VARDIR}/.modules

    if [ "$COMMAND" = refresh ]; then
       run_refresh_exit
    else
	run_init_exit
    fi

    if [ "$COMMAND" = restart -o "$COMMAND" = refresh ]; then
	if chain_exists 'UPnP -t nat'; then
	    ${IPTABLES} -t nat -S UPnP | tail -n +2 > ${VARDIR}/.UPnP
	else
	    rm -f ${VARDIR}/.UPnP
	fi
	
	if chain_exists forwardUPnP; then
	    ${IPTABLES} -S forwardUPnP | tail -n +2 > ${VARDIR}/.forwardUPnP
	else
	    rm -f ${VARDIR}/.forwardUPnP
	fi
	
	if chain_exists dynamic; then
	    ${IPTABLES} -S dynamic | tail -n +2 > ${VARDIR}/.dynamic
	else
	    rm -f ${VARDIR}/.dynamic
	fi

    else
	rm -f ${VARDIR}/.UPnP
	rm -f ${VARDIR}/.forwardUPnP

	if [ "$COMMAND" = stop -o "$COMMAND" = clear ]; then
	    if chain_exists dynamic; then
		${IPTABLES} -S dynamic | tail -n +2 > ${VARDIR}/.dynamic
	    fi
	fi

    fi

    qt1 $IPTABLES -L shorewall -n && qt1 $IPTABLES -F shorewall && qt1 $IPTABLES -X shorewall

    delete_proxyarp

    if [ -f ${VARDIR}/nat ]; then
	while read external interface; do
	    del_ip_addr $external $interface
	done < ${VARDIR}/nat

	rm -f ${VARDIR}/nat
    fi

    delete_tc1

    setup_common_rules

    setup_routing_and_traffic_shaping

    cat > ${VARDIR}/proxyarp << __EOF__
__EOF__

    if [ "$COMMAND" != refresh ]; then
	cat > ${VARDIR}/zones << __EOF__
fw firewall
loc ipv4 eth0:0.0.0.0/0
dmz1 ipv4 eth1:0.0.0.0/0
net ipv4 eth2:0.0.0.0/0 eth3:0.0.0.0/0
__EOF__
	cat > ${VARDIR}/policies << __EOF__
fw 	=>	loc	ACCEPT using chain fw2loc
fw 	=>	dmz1	ACCEPT using chain fw2dmz1
fw 	=>	net	ACCEPT using chain fw2net
loc 	=>	fw	ACCEPT using chain loc2fw
loc 	=>	dmz1	ACCEPT using chain loc2dmz1
loc 	=>	net	ACCEPT using chain loc2net
dmz1 	=>	fw	ACCEPT using chain dmz12fw
dmz1 	=>	loc	ACCEPT using chain dmz12loc
dmz1 	=>	net	ACCEPT using chain dmz12net
net 	=>	fw	DROP using chain net2fw
net 	=>	loc	DROP using chain net2loc
net 	=>	dmz1	DROP using chain net2dmz1
net 	=>	net	DROP using chain net2net
__EOF__
	cat > ${VARDIR}/marks << __EOF__
Traffic Shaping:0-16383 (0x0-0x3fff) mask 0xffff
User:16384-49152 (0x4000-0xc000) mask 0xc000
Provider:65536-16711680 (0x10000-0xff0000) mask 0xff0000
Zone: Not Enabled
Exclusion:16777216 mask 0x1000000
TProxy:33554432 mask 0x2000000
__EOF__
    fi

    > ${VARDIR}/nat

    if [ $COMMAND = restore ]; then
	iptables_save_file=${VARDIR}/$(basename $0)-iptables
	if [ -f $iptables_save_file ]; then
	    cat $iptables_save_file | $IPTABLES_RESTORE # Use this nonsensical form to appease SELinux
	else
	   fatal_error "$iptables_save_file does not exist"
	fi

	echo 1 > /proc/sys/net/ipv4/ip_forward
	progress_message2 IPv4 Forwarding Enabled

	set_state Started /data/gw.w.cn/
	run_restored_exit
    elif [ $COMMAND = refresh ]; then
	chainlist_reload

	echo 1 > /proc/sys/net/ipv4/ip_forward
	progress_message2 IPv4 Forwarding Enabled

	run_refreshed_exit
	do_iptables -N shorewall
	do_iptables -A shorewall -m recent --set --name %CURRENTTIME
	set_state Started /data/gw.w.cn/
	[ $0 = ${VARDIR}/firewall ] || cp -f $(my_pathname) ${VARDIR}/firewall
    else
	setup_netfilter
	conditionally_flush_conntrack

	echo 1 > /proc/sys/net/ipv4/ip_forward
	progress_message2 IPv4 Forwarding Enabled

	run_start_exit
	do_iptables -N shorewall

	do_iptables -A shorewall -m recent --set --name %CURRENTTIME
	set_state Started /data/gw.w.cn/
	my_pathname=$(my_pathname)
	[ $my_pathname = ${VARDIR}/firewall ] || cp -f $my_pathname ${VARDIR}/firewall
	run_started_exit
    fi

    date > ${VARDIR}/restarted
    
    case $COMMAND in
	start)
	    logger -p kern.info "$g_product started"
	    ;;
	restart)
	    logger -p kern.info "$g_product restarted"
	    ;;
	refresh)
	    logger -p kern.info "$g_product refreshed"
	    ;;
	restore)
	    logger -p kern.info "$g_product restored"
	    ;;
    esac

}

#
# Stop/restore the firewall after an error or because of a 'stop' or 'clear' command
#
stop_firewall() {
    local hack

    deletechain() {
	qt $IPTABLES -L $1 -n && qt $IPTABLES -F $1 && qt $IPTABLES -X $1
    }

    case $COMMAND in
	stop|clear|restore)
	    if chain_exists dynamic; then
		${IPTABLES}-save -t filter | grep '^-A dynamic' > ${VARDIR}/.dynamic
	    fi
	    ;;
	*)
	    set +x

	    case $COMMAND in
		start)
		    logger -p kern.err "ERROR:$g_product start failed"
		    ;;
		restart)
		    logger -p kern.err "ERROR:$g_product restart failed"
		    ;;
		refresh)
		    logger -p kern.err "ERROR:$g_product refresh failed"
		    ;;
		enable)
		    logger -p kern.err "ERROR:$g_product 'enable $g_interface' failed"
		    ;;
	    esac

	    if [ "$RESTOREFILE" = NONE ]; then
		COMMAND=clear
		clear_firewall
		echo "$g_product Cleared"

		kill $$
		exit 2
	    else
		g_restorepath=${VARDIR}/$RESTOREFILE

		if [ -x $g_restorepath ]; then
		    echo Restoring ${g_product:=Shorewall}...

		    g_recovering=Yes

		    if run_it $g_restorepath restore; then
			echo "$g_product restored from $g_restorepath"
			set_state "Restored from $g_restorepath"
		    else
			set_state "Unknown"
		    fi

		    kill $$
		    exit 2
		fi
	    fi
	    ;;
    esac

    if [ -n "$g_stopping" ]; then
	kill $$
	exit 1
    fi

    set_state "Stopping"

    g_stopping="Yes"

    deletechain shorewall

    run_stop_exit

    #
    # Enable automatic helper association on kernel 3.5.0 and later
    #
    if [ $COMMAND = clear -a -f /proc/sys/net/netfilter/nf_conntrack_helper ]; then
	echo 1 > /proc/sys/net/netfilter/nf_conntrack_helper
    fi


    if [ -f ${VARDIR}/nat ]; then
	while read external interface; do
      	    del_ip_addr $external $interface
	done < ${VARDIR}/nat

	rm -f ${VARDIR}/nat
    fi

    if [ -f ${VARDIR}/proxyarp ]; then
	while read address interface external haveroute; do
	    qtnoin $IP -4 neigh del proxy $address dev $external
	    [ -z "${haveroute}${g_noroutes}" ] && qtnoin $IP -4 route del $address/32 dev $interface
	    f=/proc/sys/net/ipv4/conf/$interface/proxy_arp
	    [ -f $f ] && echo 0 > $f
	done < ${VARDIR}/proxyarp

	rm -f ${VARDIR}/proxyarp
    fi


    delete_tc1
    undo_routing
    restore_default_route 

    [ -n "$g_debug_iptables" ] && command=debug_restore_input || command=$IPTABLES_RESTORE

    progress_message2 "Running $command..."

    $command <<__EOF__
#
# Generated by Shorewall 4.5.21.6 - Wed Mar 18 15:36:10 2015
#
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
*nat
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
COMMIT
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -i eth0 -j ACCEPT
-A INPUT -i eth1 -j ACCEPT
-A INPUT -i eth2 -j ACCEPT
-A INPUT -i eth3 -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p udp --dport 67:68 -i eth1 -j ACCEPT
-A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A FORWARD -i eth0 -o eth0 -j ACCEPT
-A FORWARD -i eth1 -o eth1 -j ACCEPT
-A FORWARD -i eth2 -o eth2 -j ACCEPT
-A FORWARD -i eth3 -o eth3 -j ACCEPT
-A FORWARD -i eth0 -o eth1 -j ACCEPT
-A FORWARD -i eth0 -o eth2 -j ACCEPT
-A FORWARD -i eth0 -o eth3 -j ACCEPT
-A FORWARD -i eth1 -o eth0 -j ACCEPT
-A FORWARD -i eth1 -o eth2 -j ACCEPT
-A FORWARD -i eth1 -o eth3 -j ACCEPT
-A FORWARD -i eth2 -o eth0 -j ACCEPT
-A FORWARD -i eth2 -o eth1 -j ACCEPT
-A FORWARD -i eth2 -o eth3 -j ACCEPT
-A FORWARD -i eth3 -o eth0 -j ACCEPT
-A FORWARD -i eth3 -o eth1 -j ACCEPT
-A FORWARD -i eth3 -o eth2 -j ACCEPT
-A FORWARD -p udp --dport 67:68 -i eth1 -o eth1 -j ACCEPT
COMMIT
__EOF__

    if [ $? != 0 ]; then
	error_message "ERROR: $command Failed."
    fi

    echo 1 > /proc/sys/net/ipv4/ip_forward
    progress_message2 IPv4 Forwarding Enabled

    run_stopped_exit


    set_state "Stopped"
    logger -p kern.info "$g_product Stopped"

    case $COMMAND in
    stop|clear)
	;;
    *)
	#
	# The firewall is being stopped when we were trying to do something
	# else. Kill the shell in case we're running in a subshell
	#
	kill $$
	;;
    esac
}

#
# Handle the "up" and "down" commands
#
updown() # $1 = interface
{
    local state
    state=cleared

    progress_message3 "$g_product $COMMAND triggered by $1"

    if shorewall_is_started; then
	state=started
    elif [ -f ${VARDIR}/state ]; then
	case "$(cat ${VARDIR}/state)" in
	    Stopped*)
		state=stopped
		;;
	    Cleared*)
		;;
	    *)
		state=unknown
		;;
	esac
    else
	state=unknown
    fi

    case $1 in
	eth0|eth1|eth2|eth3)
	    case $state in
		started)
		    COMMAND=restart
		    progress_message3 "$g_product attempting restart"
		    detect_configuration
		    define_firewall
		    ;;
		*)
		    progress_message3 "$COMMAND on interface $1 ignored"
		    ;;
	    esac
    esac
}

###############################################################################
# Code imported from /usr/share/shorewall/prog.footer
###############################################################################
#
# Give Usage Information
#
usage() {
    echo "Usage: $0 [ options ] <command>"
    echo
    echo "<command> is one of:"
    echo "   start"
    echo "   stop"
    echo "   clear"
    echo "   disable <interface>"
    echo "   down <interface>"
    echo "   enable <interface>"
    echo "   reset"
    echo "   refresh"
    echo "   restart"
    echo "   status"
    echo "   up <interface>"
    echo "   version"
    echo
    echo "Options are:"
    echo
    echo "   -v and -q        Standard Shorewall verbosity controls"
    echo "   -n               Don't update routing configuration"
    echo "   -p               Purge Conntrack Table"
    echo "   -t               Timestamp progress Messages"
    echo "   -V <verbosity>   Set verbosity explicitly"
    echo "   -R <file>        Override RESTOREFILE setting"
    exit $1
}

checkkernelversion() {

    return 0
}

################################################################################
# E X E C U T I O N    B E G I N S   H E R E				       #
################################################################################
#
# Start trace if first arg is "debug" or "trace"
#
g_debug_iptables=

if [ $# -gt 1 ]; then
    if [ "x$1" = "xtrace" ]; then
	set -x
	shift
    elif [ "x$1" = "xdebug" ]; then
	g_debug_iptables=Yes
	shift
    fi
fi
#
# Map VERBOSE to VERBOSITY for compatibility with old Shorewall[6]-lite installations
#
[ -z "$VERBOSITY" ] && [ -n "$VERBOSE" ] && VERBOSITY=$VERBOSE
#
# Map other old exported variables
#
g_purge=$PURGE
g_noroutes=$NOROUTES
g_timestamp=$TIMESTAMP
g_recovering=$RECOVERING

initialize

if [ -n "$STARTUP_LOG" ]; then
    touch $STARTUP_LOG
    chmod 0600 $STARTUP_LOG
    if [ ${SHOREWALL_INIT_SCRIPT:-0} -eq 1 ]; then
	#
	# We're being run by a startup script that isn't redirecting STDOUT
	# Redirect it to the log
	#
	exec 2>>$STARTUP_LOG
    fi
fi

finished=0

while [ $finished -eq 0 -a $# -gt 0 ]; do
    option=$1
    case $option in
	-*)
	    option=${option#-}

	    [ -z "$option" ] && usage 1

	    while [ -n "$option" ]; do
		case $option in
		    v*)
			[ $VERBOSITY -lt 2 ] && VERBOSITY=$(($VERBOSITY + 1 ))
			option=${option#v}
			;;
		    q*)
			[ $VERBOSITY -gt -1 ] && VERBOSITY=$(($VERBOSITY - 1 ))
			option=${option#q}
			;;
		    n*)
			g_noroutes=Yes
			option=${option#n}
			;;
		    t*)
			g_timestamp=Yes
			option=${option#t}
			;;
		    p*)
			g_purge=Yes
			option=${option#p}
			;;
		    r*)
			g_recovering=Yes
			option=${option#r}
			;;
		    V*)
			option=${option#V}

			if [ -z "$option" -a $# -gt 0 ]; then
			    shift
			    option=$1
			fi

			if [ -n "$option" ]; then
			    case $option in
				-1|0|1|2)
				    VERBOSITY=$option
				    option=
				    ;;
				*)
				    startup_error "Invalid -V option value ($option)"
				    ;;
			    esac
			else
			    startup_error "Missing -V option value"
			fi
			;;
		    R*)
			option=${option#R}

			if [ -z "$option" -a $# -gt 0 ]; then
			    shift
			    option=$1
			fi

			if [ -n "$option" ]; then
			    case $option in
				*/*)
	    			    startup_error "-R must specify a simple file name: $option"
				    ;;
				.safe|.try|NONE)
				    ;;
				.*)
				    error_message "ERROR: Reserved File Name: $RESTOREFILE"
				    exit 2
				    ;;
			    esac
			else
			    startup_error "Missing -R option value"
			fi

			RESTOREFILE=$option
			option=
			;;
		    *)
			usage 1
			;;
		esac
	    done
	    shift
	    ;;
	*)
	    finished=1
            ;;
    esac
done

COMMAND="$1"

case "$COMMAND" in
    start)
	[ $# -ne 1 ] && usage 2
	if product_is_started; then
	    error_message "$g_product is already Running"
	    status=0
	else
	    progress_message3 "Starting $g_product...."
	    if checkkernelversion; then
		detect_configuration
		define_firewall
		status=$?
		if [ $status -eq 0 ]; then
		    [ -n "$SUBSYSLOCK" ] && touch $SUBSYSLOCK
		    progress_message3 "done."
		fi
	    fi
	fi
	;;
    stop)
	[ $# -ne 1 ] && usage 2
	if checkkernelversion; then
	    progress_message3 "Stopping $g_product...."
	    detect_configuration
	    stop_firewall
	    status=0
	    [ -n "$SUBSYSLOCK" ] && rm -f $SUBSYSLOCK
	    progress_message3 "done."
	fi
	;;
    reset)
	if ! product_is_started ; then
	    error_message "$g_product is not running"
	    status=2
	elif checkkernelversion; then
	    if [ $# -eq 1 ]; then
		$g_tool -Z
		$g_tool -t mangle -Z
		date > ${VARDIR}/restarted
		status=0
		progress_message3 "$g_product Counters Reset"
	    else
		shift
		status=0
		for chain in $@; do
		    if chain_exists $chain; then
			if qt $g_tool-Z $chain; then
			    progress_message3 "Filter $chain Counters Reset"
			else
			    error_message "ERROR: Reset of chain $chain failed"
			    status=2
			    break
			fi
		    else
			error_message "WARNING: Filter Chain $chain does not exist"
		    fi
		done
	    fi
	fi
	;;
    restart)
	[ $# -ne 1 ] && usage 2
	if product_is_started; then
	    progress_message3 "Restarting $g_product...."
	else
	    error_message "$g_product is not running"
	    progress_message3 "Starting $g_product...."
	    COMMAND=start
	fi

	if checkkernelversion; then
	    detect_configuration
	    define_firewall
	    status=$?
	    if [ -n "$SUBSYSLOCK" ]; then
 		[ $status -eq 0 ] && touch $SUBSYSLOCK || rm -f $SUBSYSLOCK
            fi

	    [ $status -eq 0 ] && progress_message3 "done."
	fi
	;;
    refresh)
	[ $# -ne 1 ] && usage 2
	if product_is_started; then
	    progress_message3 "Refreshing $g_product...."
	    if checkkernelversion; then
		detect_configuration
		define_firewall
		status=$?
		[ $status -eq 0 ] && progress_message3 "done."
	    fi
	else
	    echo "$g_product is not running" >&2
	    status=2
	fi
	;;
    restore)
	[ $# -ne 1 ] && usage 2
	if checkkernelversion; then
	    detect_configuration
	    define_firewall
	    status=$?
	    if [ -n "$SUBSYSLOCK" ]; then
 		[ $status -eq 0 ] && touch $SUBSYSLOCK || rm -f $SUBSYSLOCK
            fi
	    [ $status -eq 0 ] && progress_message3 "done."
	fi
	;;
    clear)
	[ $# -ne 1 ] && usage 2
	progress_message3 "Clearing $g_product...."
	if checkkernelversion; then
	    clear_firewall
	    status=0
	    if [ -n "$SUBSYSLOCK" ]; then
		rm -f $SUBSYSLOCK
	    fi
	    progress_message3 "done."
	fi
	;;
    status)
	[ $# -ne 1 ] && usage 2
	[ $VERBOSITY -ge 1 ] && echo "$g_product-$SHOREWALL_VERSION Status at $(hostname) - $(date)" &&	echo
	if product_is_started; then
	    [ $VERBOSITY -ge 1 ] && echo "$g_product is running"
	    status=0
	else
	    [ $VERBOSITY -ge 1 ] && echo "$g_product is stopped"
	    status=4
	fi

	if [ -f ${VARDIR}/state ]; then
	    state="$(cat ${VARDIR}/state)"
	    case $state in
		Stopped*|Clear*)
		    status=3
		    ;;
	    esac
	else
	    state=Unknown
	fi
	[ $VERBOSITY -ge 1 ] && echo "State:$state" && echo
	;;
    up|down)
	[ $# -eq 1 ] && exit 0
	shift
	[ $# -ne 1 ] && usage 2
	mutex_on
	( updown $1 )
	mutex_off
	status=0
	;;
    enable)
	[ $# -eq 1 ] && exit 0
	shift
	[ $# -ne 1 ] && usage 2
	if product_is_started; then
	    detect_configuration
	    enable_provider $1
	fi
	status=0
	;;
    disable)
	[ $# -eq 1 ] && exit 0
	shift
	[ $# -ne 1 ] && usage 2
	if product_is_started; then
	    detect_configuration
	    disable_provider $1
	fi
	status=0
	;;
    version)
	[ $# -ne 1 ] && usage 2
	echo $SHOREWALL_VERSION
	status=0
	;;
    help)
	[ $# -ne 1 ] && usage 2
	usage 0
	;;
    *)
	usage 2
	;;
esac

exit $status
